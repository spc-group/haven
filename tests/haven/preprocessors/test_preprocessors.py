from unittest.mock import MagicMock

import pytest
from bluesky import RunEngine
from bluesky import plans as bp
from bluesky.callbacks import CallbackBase
from ophyd.sim import SynAxis, det

from haven import baseline_decorator, baseline_wrapper
from haven.preprocessors import (
    inject_metadata_wrapper,
)


@pytest.fixture()
def RE():
    return RunEngine({})


def test_baseline_wrapper(sim_registry, aps, RE):
    # Create a test device
    motor_baseline = SynAxis(name="baseline_motor", labels={"motors", "baseline"})
    sim_registry.register(motor_baseline)
    # Set up a callback to motor streams generated by runengine
    cb = CallbackBase()
    cb.start = MagicMock()
    cb.descriptor = MagicMock()
    cb.event = MagicMock()
    cb.stop = MagicMock()
    plan = bp.count([det], num=1)
    plan = baseline_wrapper(plan, devices="baseline")
    RE(plan, cb)
    # Check that the callback has the baseline stream inserted
    assert cb.start.called
    assert cb.descriptor.call_count > 1
    baseline_doc = cb.descriptor.call_args_list[0][0][0]
    primary_doc = cb.descriptor.call_args_list[1][0][0]
    assert baseline_doc["name"] == "baseline"
    assert "baseline_motor" in baseline_doc["data_keys"].keys()


def test_baseline_decorator(sim_registry, aps, RE):
    """Similar to baseline wrapper test, but used as a decorator."""
    # Create the decorated function before anything else
    func = baseline_decorator(devices="motors")(bp.count)
    # Create a test device
    motor_baseline = SynAxis(name="baseline_motor", labels={"motors"})
    sim_registry.register(motor_baseline)
    # Set up a callback to motor streams generated by runengine
    cb = CallbackBase()
    cb.start = MagicMock()
    cb.descriptor = MagicMock()
    cb.event = MagicMock()
    cb.stop = MagicMock()
    plan = func([det], num=1)
    RE(plan, cb)
    # Check that the callback has the baseline stream inserted
    assert cb.start.called
    assert cb.descriptor.call_count > 1
    baseline_doc = cb.descriptor.call_args_list[0][0][0]
    primary_doc = cb.descriptor.call_args_list[1][0][0]
    assert baseline_doc["name"] == "baseline"
    assert "baseline_motor" in baseline_doc["data_keys"].keys()


async def test_inject_metadata(sim_registry, aps, monkeypatch, mocker):
    """Check that a basic, minial start document is createD with defaults."""
    monkeypatch.setenv("EPICS_HOST_ARCH", "PDP11", prepend=False)
    monkeypatch.setenv("PYEPICS_LIBCA", "/dev/null", prepend=False)
    monkeypatch.setenv("EPICS_CA_MAX_ARRAY_BYTES", "16", prepend=False)
    # Check that the callback has the correct metadata
    plan = bp.count([det], num=1, md={"purpose": "testing"})
    plan = inject_metadata_wrapper(
        plan,
        config={
            "metadata": {
                "xray_source": "25-ID-C",
            }
        },
    )
    msgs = list(plan)
    # Check versions
    start_doc = msgs[1].kwargs
    # from pprint import pprint
    # print("In tests")
    # pprint(msgs)
    assert msgs[1].command == "open_run"
    assert "version_haven" in start_doc.keys()
    assert "version_bluesky" in start_doc.keys()
    # Check metadata keys
    expected_keys = [
        "EPICS_HOST_ARCH",
        "xray_source",
        "epics_libca",
        "EPICS_CA_MAX_ARRAY_BYTES",
        "login_id",
        "pid",
        "plan_name",
        "detectors",
        "hints",
        "purpose",
    ]
    missing_keys = set(expected_keys) - set(start_doc.keys())
    assert not missing_keys, missing_keys
    # Check metadata values
    expected_data = {
        "EPICS_HOST_ARCH": "PDP11",
        "xray_source": "25-ID-C",
        "epics_libca": "/dev/null",
        "EPICS_CA_MAX_ARRAY_BYTES": "16",
        "plan_name": "count",
        "purpose": "testing",
    }
    for key, val in expected_data.items():
        assert start_doc[key] == val, f"{key}: {start_doc[key]}"


# -----------------------------------------------------------------------------
# :author:    Mark Wolfman
# :email:     wolfman@anl.gov
# :copyright: Copyright Â© 2023, UChicago Argonne, LLC
#
# Distributed under the terms of the 3-Clause BSD License
#
# The full license is in the file LICENSE, distributed with this software.
#
# DISCLAIMER
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# -----------------------------------------------------------------------------
